# Module

`Module` is an interface for specifying bindings.

```c++
namespace yadif {
  struct Module {
    virtual void configure() const = 0;
  };
}
```

You have to derive from `Module` and override the `configure()` method to specify bindings.

#Binding Keys

First a general word about bindings. A binding must turn static information (types) into
executable code. For this yadif uses template functions with explicitly specified template parameters. The combination of type and optional annotation is the actual binding key internally used by Yadif. So everywhere you see a `<key>` in the reference, it may be specified either as `<T>` or as `<T, Annotation<A>>`.

Note that a type is used as annotation. If an annotation is present, it must be wrapped by the `Annotation<>` template to clearly distinguish it from the type used for binding.

#Specifying Bindings

Within the overridden `configure()` method, each binding starts by calling the protected `bind()` method.

```c++
bind<interface key>()
```

This function returns a temporary `Binder`object that is used to collect the other binding parameters.

###Type Binding

A type binding is used to bind an interface type to an implementation type. It is specified by appending

```c++
.to<implementation_key>()
``` 

to the `bind()` specification.

###Provider Binding

A provider binding binds an instance of a callable provider to a type.  It is specified by appending

```c++
.toProvider(P)
``` 

to the `bind()` specification.

As each instance created by yadif must ultimately be generated by a provider, the provider concept is rather flexible.

A Provider can be anything that is

* either callable by `()` or by `(Injector&)`
* and returns something that can be used to construct a `std::shared_ptr<interface>`.

So a provider may be a function, a functor or a lambda. It may return a raw pointer or a smart pointer.

:exclamation: A binding must bind either to an implementation or to an provider. 

###Singleton Binding

For binding an interface as a singleton instance, append

```c++
.asSingleton()
``` 

or

```c++
.asEagerSingleton()
```

to the binding. For details check the [singleton reference](reference_singleton.md).


###Scope Binding

A scope may be used to add a context to a binding. In fact singleton bindings are implemented as a scope.  `.asSingleton()` is just an alias for `.in(SingletonScope{})`.

For details check the [scope reference](reference_singleton.md).

---

Next: [Injector](reference_injector.md)
